<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Godot Engine"><meta name=description content="The GLES2 backend is getting closer and closer to completion, this progress report shows a detailed overview of the steps taken to implement PBR."><meta name=theme-color content="#3d8fcc"><meta property="og:site_name" content="Godot Engine"><meta property="og:url" content="https://godotengine.org/article/gles2-and-gdnative-progress-report-6/"><meta name=twitter:site content="@godotengine"><meta property="og:title" content="GLES2 and GDNative, progress report #6"><meta property="og:description" content="The GLES2 backend is getting closer and closer to completion, this progress report shows a detailed overview of the steps taken to implement PBR."><meta property="og:image" content="https://godotengine.org/storage/app/uploads/public/5b1/817/ac2/5b1817ac23235651080146.png"><meta property="og:type" content="article"><meta name=twitter:card content="summary_large_image"><title>GLES2 and GDNative, progress report #6</title><link rel=alternate type=application/rss+xml title="Godot News" href=/rss.xml><link rel=icon href=/assets/favicon.png sizes=any><link rel=icon href=/assets/favicon.svg type=image/svg+xml><link rel=stylesheet href=/assets/css/main.css?112><link rel=stylesheet href=/assets/css/tobii.min.css><link rel=preload as=font href=/assets/fonts/Montserrat-Bold.woff2 crossorigin><link rel=preload as=font href=/assets/fonts/Montserrat-ExtraBold.woff2 crossorigin><link rel=me href=https://mastodon.gamedev.place/@godotengine><input type=checkbox id=nav_toggle_cb><header><div class="container flex align-center"><div id=nav_head><a href=/ id=logo-link><img class=nav-logo src=/assets/logo.svg width=136 height=48 alt="Godot Engine">
<img class="nav-logo dark-logo" src=/assets/logo_dark.svg width=136 height=48 alt="Godot Engine"></a>
<label for=nav_toggle_cb id=nav_toggle_btn><img src=/assets/icons/hamburger.svg width=24 height=24 alt="Main menu"></label></div><nav id=nav><ul class=left><li><a href=/features/>Features</a><li class=only-on-mobile><a href=/showcase/>Showcase</a><li><a href=/blog/>Blog</a><li><a href=/community/>Community</a><li><a href=/contact/>About</a><li><a href=https://godotengine.org/asset-library/asset>Assets</a></ul><ul class=right><li><a href=/download/windows/ class=set-os-download-url>Download</a><li><a href=https://docs.godotengine.org>Docs</a><li><a href=https://docs.godotengine.org/en/stable/community/contributing/index.html>Contribute</a><li class=fund><a href=https://fund.godotengine.org>❤&#xFE0E; Donate</a></ul></nav></div></header><main><style>body{background-color:var(--background-color)}h1{margin-bottom:8px;margin-top:32px}:not(pre)>code{background:var(--code-background-color);padding:1px 4px;font-size:.95em;border-radius:3px}pre{background:var(--codeblock-background-color);color:var(--codeblock-color)}pre code{display:block;overflow-x:auto;padding:.5em}.date-big{line-height:2;margin-left:32px}article{background-color:var(--base-color);box-shadow:0 3px 2px rgba(0,0,0,.15)}figure{margin:0}figure img{margin:0}article img,article video{max-width:100%;height:auto;display:block;margin:auto;margin-top:16px;margin-bottom:16px}article h1{margin-top:64px}article h2,article h3,article h4{margin-top:42px}.article-info{display:flex;flex-direction:column;gap:8px}.article-metadata{display:flex;gap:24px;align-items:center;font-family:var(--header-font-family);margin-bottom:12px}@media(max-width:900px){.article-metadata{flex-direction:column;align-items:flex-start;gap:16px}}.article-author{color:var(--base-color-text-subtitle-date);font-weight:700;font-size:18px;flex-grow:1;display:flex;gap:12px;align-items:center}.article-author .avatar{border-radius:100%;margin:0}.article-author .by{color:var(--base-color-text-subtitle)}.article-metadata .date{color:var(--base-color-text-subtitle-date)}.article-metadata .date.post-recent-highlight{color:var(--post-recent-highlight-color);opacity:.8}.article-metadata .date.post-recent-highlight::after{font-size:80%;content:"NEW";border:2px solid var(--post-recent-highlight-color);padding:2px 3px;margin-left:8px}.tag.active{filter:saturate(.75)}@media screen and (min-width:900px){article .content{width:70%;margin:auto}}@media(max-width:900px){body{background-color:var(--base-color)}article{background-color:initial;box-shadow:none}article img:first-child,article video:first-child{max-width:100%}}</style><link rel=stylesheet href=/assets/css/highlight.obsidian.min.css><div class=container><article class=padded><div class="content article-container"><figure class=article-cover><img src=/storage/app/uploads/public/5b1/817/ac2/5b1817ac23235651080146.png title alt=" " class=rounded-lg style=width:100%;height:auto;background-color:initial></figure><div class=article-info><h1>GLES2 and GDNative, progress report #6</h1><div class=article-metadata><div class=article-author><span>By:</span>
<img class=avatar width=25 height=25 src=/assets/images/authors/default_avatar.svg alt=karroffel loading=lazy>
<span class=by>karroffel</span></div><span class=date data-post-date="2018-06-06 00:00:00 +0000">6 June 2018</span></div><div class=tags><a href=/blog/progress-report><div class="tag active">Progress Report</div></a></div></div><div class="card card-warning"><p>This article is from <strong>June 2018</strong>, some of its contents might be outdated and no longer accurate.<br>You can find up-to-date information about the engine in the <a href=https://docs.godotengine.org/en/stable/>official documentation</a>.</div><div class=article-body><h2 id=introduction>Introduction</h2><p>The GLES2 backend is getting closer and closer to completion, this progress report shows a detailed overview of the steps taken to implement PBR.<h2 id=roadmap>Roadmap</h2><h4 id=done-may-2018>Done May 2018</h4><ul><li>enviroment relections<li>cubemap filtering<li>implement BRDF<li>omni lights<li>lambert+phong<li>normal maps<li>rewrite OAHashMap to use RobinHood hashing<li>improved C++ bindings compilation workflow<li>fixed a GDNative binary compatibility bug</ul><h4 id=planned-june-2018>Planned June 2018</h4><ul><li>finish lights<li>shadow mapping<li>reflection probes<li>lightmaps<li>particles<li>get NativeScript 1.1 and the C++ bindings release ready</ul><h2 id=details-about-work-in-may-2018>Details about work in May 2018</h2><h3 id=environment-reflections>environment reflections</h3><p>At the end of <a href=https://godotengine.org/article/gles2-and-gdnative-progress-report-5>last month</a> I was able to load and show a skybox as a background. The next step is to get reflecting materials to show that sky. Or more specifically: the light reflected from a surface should include radiance from the sky.<p>The first step to getting something like that shown is to know where in the world you actually are. This is a screenshot that displays the object-space position of each pixel as the color.<p><img src=/storage/app/uploads/public/5b1/7f9/2ed/5b17f92ed8c15621389924.png alt=positions.png><p>That’s not really that interesting to look at, so let’s try to use SOME MATH!!! (but mostly just the <code class="language-plaintext highlighter-rouge">textureCube()</code> function in GLSL)<p><img src=/storage/app/uploads/public/5b1/7f9/79c/5b17f979c6f5f904594110.png alt="Screenshot from 2018-05-06 17-51-42.png"><p>Heyyy, this pretty much looks like the sky projected onto the meshes, that’s better!<p>At that point of development, the sky reflection didn’t respond to the camera position, so it basically looked like the sky was painted ontop of the mesh. That was fixed by <a href=https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/reflect.xhtml><em>reflecting</em></a> the view-vector with the normal of the current pixel.<p>The next step is to do proper cubemap filtering.<h3 id=cubemap-filtering>cubemap filtering</h3><p>A polished metal-ball doesn’t reflect light in the same way as a rubber-ball or piece of wood does. To implement these different behaviors we could do some complex operations <strong>per pixel</strong> and possibly index pixels of the skymap and surrounding objects <em>multiple times</em>, but because graphic programmers are very empathic creatures we don’t want the PC to do more work than necessary to achieve a believable effect.<p>So instead the sky gets blurred with different “intensities” and that’s what will be used for different “roughness” values of the materials.<p>This blurring is the “cubemap filtering”.<p>Because blurry images need less detail than non-blurry images it would be handy to store those blurred versions in a <em>mipmap</em>.<p>A <a href=https://en.wikipedia.org/wiki/Mipmap>mipmap</a> is a smaller version of the original texture, usually filtered in a special way to make them look nicer when they are viewed from an angle or far away. OpenGL usually generates those for you. It <em>halves</em> the resolution of the image until there’s only one pixel left.<p>( This is why for pixel-art games you often either change the filtering mode of textures or need to disable mipmaps to make the game look nice and sharp. )<p>For the sky some custom custom filtering is wanted, in this case a <em>blur</em>. So the lower-resolution images need to be generated manually and OpenGL needs to know that it should use those images instead of using its own method.<p>This is done <a href=https://github.com/karroffel/godot/blob/9320ea98b7f575dd80a171e5c0e6d76d4b6f7120/drivers/gles2/rasterizer_storage_gles2.cpp#L910-L931>here</a> in the code.<p>Because now the mipmap-level (the amount of “small-ness” of the texture) has a different use case we need to access it manually in the shaders rather than letting OpenGL handle that for us automatically. (This is done using the <code class="language-plaintext highlighter-rouge">textureCubeLod()</code> function, where the “level of detail” - so the mipmap level - can be specified explicitly)<p>So for the beginning I didn’t actually do any blurring, I just gradually made the sky more white to see if it actually works.<p><br><p>…<p><br><p>And of course it didn’t, but here are some screenshots that look cool.<p><img src=/storage/app/uploads/public/5b1/7ff/eaa/5b17ffeaa93ba142637922.png alt="Screenshot from 2018-05-08 17-24-51.png"><p><img src=/storage/app/uploads/public/5b1/800/109/5b1800109ece8702732231.png alt="Screenshot from 2018-05-08 17-36-01.png"><p>After all this was working properly the actual <em>blurring</em> had to be implemented. This actually turned out to be quite a problem.<p>The blurring is done by selecting a few mostly-evenly-distributed points on the image. Then those points are mixed in a way that calculates a color that looks cool basically.<p>The problem I was facing was that the algorithm to distribute points on the texture runs in the fragment shader, and the function used in the GLES3 backend is using a Hammersley distribution. The implementation is based on <a href=http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html>this post</a> and uses bit-shifting. Bitshifting operations are not supported in GLSL ES 1.0.<p>I tried to play around a bit to see if I can find a good distribution with some number-crunching. I got interesting and almost okay-ish results.<div style=position:relative;padding-bottom:54%><iframe src=https://gfycat.com/ifr/FailingRichIbex frameborder=0 scrolling=no width=100% height=100% style=position:absolute;top:0;left:0 allowfullscreen></iframe></div><p><img src=/storage/app/uploads/public/5b1/803/09b/5b180309bcc21218376946.png alt="Screenshot from 2018-05-12 18-21-54.png"><p>This was the closest I could get, but it was all very hacky.<p>For the lack of a better and proven alternative I chose to generate those values on the CPU and writing them into a texture.<p>The results of that were quite nice (as expected).<p><img src=/storage/app/uploads/public/5b1/804/b3f/5b1804b3f3000145463588.png alt="Screenshot from 2018-05-12 19-03-52.png"><p><img src=/storage/app/uploads/public/5b1/804/bf9/5b1804bf9c16b408554059.png alt="Screenshot from 2018-05-12 19-06-20.png"><p>(Also having a proper skymap makes a really huge difference on quality, so just as a side tip: search for good environment maps, they shape the perception of graphics quality a lot!)<p>With all that in place, all meterials where behaving as if they had metallic = 1 but a variable roughness.<p>The cubemap filtering shader can be found <a href=https://github.com/karroffel/godot/blob/9320ea98b7f575dd80a171e5c0e6d76d4b6f7120/drivers/gles2/shaders/cubemap_filter.glsl>here</a>.<p>There are still some things to iron out (like cubemap seams), but this is a good starting point.<h3 id=implement-brdf>implement BRDF</h3><p>To properly (in a PBR sense) support metalness and roughness, a <a href=https://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function>Bidirectional reflectance distribution function</a>, short BRDF, is needed.<p>There are some great references and materials out there that can go into detail a lot better than I can, so I will just plug <a href=https://academy.allegorithmic.com/courses/b6377358ad36c444f45e2deaa0626e65>some</a> <a href=https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf>of</a> <a href=https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf>them</a>.<p>So metallic and dielectric materials work now!<p><img src=/storage/app/uploads/public/5b1/808/0b7/5b18080b754a7040029079.png alt="Screenshot from 2018-05-30 21-48-14.png"><p>(for some reason dielectric materials are darker than they should be, I’ll have to fix that…)<div style=position:relative;padding-bottom:57%><iframe src=https://gfycat.com/ifr/InsecureEnlightenedAfricangoldencat frameborder=0 scrolling=no width=100% height=100% style=position:absolute;top:0;left:0 allowfullscreen></iframe></div><div style=position:relative;padding-bottom:57%><iframe src=https://gfycat.com/ifr/ClearcutGorgeousAustraliankelpie frameborder=0 scrolling=no width=100% height=100% style=position:absolute;top:0;left:0 allowfullscreen></iframe></div><h3 id=omni-lights>omni lights</h3><p>With basic materials working and environment mapping in place, the next task on the list is lighting.<p>The GLES2 backend is a forward renderer, that means each gets shaded once. The counter-part - deferred rendering - renders each of the objects properties into a separate framebuffer. Lights then combine those properties dependeing on their parameters.<p>Because the GLES2 specification is quite limiting in some parts, the lighting uses a “multi-pass” approach. This means that all the objects that are affected by a light have to be rendered again and the “light difference” will be blended over the “base rendering” of the object.<p>This happens for all objects for all lights. The GLES3 backend can render all lights for each object in one pass, unfortunately I can’t go down that route :(<p>The first thing I tackled were OmniLights, which are like points that illuminate the area around them.<p>The strength of the light depends on the normal of the object and the distance to the light.<p><img src=/storage/app/uploads/public/5b1/80b/d4e/5b180bd4ec712376953252.png alt=Screenshot_2018-05-19_11-01-24.png><p><img src=/storage/app/uploads/public/5b1/80b/f81/5b180bf816959644059905.png alt=Screenshot_2018-05-21_14-23-25.png><h3 id=lambertphong>lambert+phong</h3><p>The above pictures where achieved by blindly blending the color of the light over the object. It didn’t take into account the metalness or roughness, as well as the “specular blob”.<p>So the next step was making sure that the material parameters would be respected properly.<p>With PBR, light reflection is divided into two categories: specular reflection and diffuse reflection.<p>The “big” part (diffuse reflection) of a light influence on an object is achieved by <a href=https://en.wikipedia.org/wiki/Lambertian_reflectance>“lambert” shading</a>. This only affects rough surfaces.<p>The specular blob (here through specular reflection) part is done with <a href=https://en.wikipedia.org/wiki/Phong_shading>“phong shading”</a>.<p>They are both <a href=https://github.com/karroffel/godot/blob/9320ea98b7f575dd80a171e5c0e6d76d4b6f7120/drivers/gles2/shaders/scene.glsl#L301-L321>pretty simple to implement</a>, but the lambert model has been modified to be in-line with PBR and energy conservation.<h3 id=normal-maps>normal maps</h3><p>Until then I didn’t implement normal maps properly as they require some special care in the shader, but it was about time, and with that in place things are starting to look pretty good!<p><img src=/storage/app/uploads/public/5b1/810/546/5b1810546d2e6990390907.png alt=Screenshot_2018-06-04_16-04-01.png><p><img src=/storage/app/uploads/public/5b1/810/5eb/5b18105eb1f10186377075.png alt=Screenshot_2018-06-04_16-04-36.png><h3 id=rewrite-oahashmap-to-use-robinhood-hashing>rewrite OAHashMap to use RobinHood hashing</h3><p>I was working on a small hashmap implementation in my freetime and read more about RobinHood hashing, which is a pretty nifty addition to regular open adressing hash maps.<p>A while ago, I implemented a new hashmap type for Godot that should be more cache friendly for situations where high performance is critical (for example CSG).<p>The main HashMap implementation in Godot uses chaining and many dynamic memory allocations. If a hash collision occurs then the elements will be chained in a linked-list kind of manner. This is pretty bad for cache misses but in most cases it’s not a problem that you need to deal with.<p>Open adressing uses flat arrays and use the hash as an index into the array. If a collision occurs then the next free spot will be used. This makes lookups more memory local.<p>One downside to that is that if the hashmap becomes more and more filled, the average time to find the entry you are looking for grows bigger and bigger.<p>RobinHood hashing enhances that system by “stealing from the rich and giving to the poor”. Basically it shifts elements around to average out the distance of the place where an entry should be and where it actually is. This means that lookups can be aborted a lot faster and in general the lookup times are much faster. Also they can be used with way higher fill factors than regular open adressing.<p>This is all pretty technical, but if you are interested, the code can be found <a href=https://github.com/godotengine/godot/blob/af15a1f10e9928d545065952b123b3eaa6f4b036/core/oa_hash_map.h>here</a>.<h3 id=improved-c-bindings-compilation-workflow>improved C++ bindings compilation workflow</h3><p>Until now, compiling the C++ bindings was a multi-step process that required setting up paths correctly and having a Godot tool-binary around.<p>I added the dependencies as git submodules and files so that the project is now compilable in one command.<p>This should hopefully lower the entry of barrier to get started with C++ projects and Godot.<h3 id=fixed-a-gdnative-binary-compatibility-bug>fixed a GDNative binary compatibility bug</h3><p>Recently a <a href=https://github.com/godotengine/godot/pull/18125>compatibility bug was found</a> with the way the Godot API struct was constructed. This has been unnoticed for a while and caused problems when cross compiling libraries. This has been resolved now and shouldn’t cause any issues from now on.<h2 id=future>Future</h2><p>The GLES2 backend is getting closer to completion and the major things missing are shadows, reflection probes and light mapping. The 3.1 alpha is planned to be soon, so those features will hopefully be ready to test by then.<p>As always, thanks for the support on Patreon and also thanks to all the people that are interested in Godot and spread the word around!<h2 id=seeing-the-code>Seeing the code</h2><p>If you are interested in the GLES2 related code, you can see all the commits in my <a href=https://github.com/karroffel/godot/tree/gles2>fork</a> on GitHub. Other contributions are linked in the sections above.</div></div></article></div><link rel=stylesheet href=/assets/css/anchor-link.css?1><link rel=stylesheet href=/assets/css/article-cards.css?2><script src=/assets/js/anchor-link.js></script>
<script>document.addEventListener('DOMContentLoaded',()=>{window.applyAnchorLinks('.article-body'),document.querySelectorAll('.article-cover img, .article-body img').forEach(b=>{if(b.classList.contains('lightbox-ignore'))return;const a=document.createElement('a');a.href=b.src,a.classList.add('lightbox'),a.dataset.group='article',b.parentNode.appendChild(a),a.appendChild(b)})})</script></main><footer><div class="container flex footer-container"><div id=copyright><p>© 2007-2024 Juan Linietsky, Ariel Manzur and <a href=https://github.com/godotengine/godot/blob/master/AUTHORS.md target=_blank rel=noopener>contributors</a>.<br>Hosted by the <a href=https://godot.foundation/ target=_blank rel=noopener>Godot Foundation</a>.<br>Website <a href=https://github.com/godotengine/godot-website target=_blank rel=noopener>source code on GitHub</a>.</div><div id=sitemap><ul class=sitemap-group><li><strong>Get Godot</strong><li><a href=/download/windows/ class=set-os-download-url>Download</a><li><a href=/download/archive/>Release Archive</a><li><a href=https://editor.godotengine.org/releases/latest/>Web Editor</a><li>&nbsp;<li><strong>Public Relations</strong><li><a href=/blog/>Blog</a><li><a href=/community/>Communities and Events</a><li><a href=/press/>Press Kit</a></ul><ul class=sitemap-group><li><strong>About Godot</strong><li><a href=/features/>Features</a><li><a href=/showcase/>Showcase</a><li><a href=/education/>Education</a><li><a href=/license/>License</a><li><a href=/code-of-conduct/>Code of Conduct</a><li><a href=/privacy-policy/>Privacy Policy</a><li><a href=https://fund.godotengine.org>Donate</a></ul><ul class=sitemap-group><li><strong>Project Team</strong><li><a href=/governance/>Governance</a><li><a href=/teams/>Teams</a><li>&nbsp;<li><strong>Extra Resources</strong><li><a href=https://godotengine.org/asset-library/asset>Asset Library</a><li><a href=https://docs.godotengine.org>Documentation</a><li><a href=https://github.com/godotengine>Code Repository</a></ul></div><div id=social class=dark-desaturate><h4 class=text-right><a href=/contact/>Contact us</a></h4><div class="flex justify-space-between" style=gap:3px><a href=https://github.com/godotengine target=_blank rel=noopener><img src=/assets/footer/github_logo.svg width=32 height=32 alt=GitHub></a>
<a href=https://mastodon.gamedev.place/@godotengine target=_blank rel=noopener><img src=/assets/footer/mastodon_logo.svg width=32 height=32 alt=Mastodon></a>
<a href=https://twitter.com/godotengine target=_blank rel=noopener><img src=/assets/footer/twitter_logo.svg width=32 height=32 alt=Twitter></a>
<a href=https://www.facebook.com/groups/godotengine/ target=_blank rel=noopener><img src=/assets/footer/facebook_logo.svg width=32 height=32 alt=Facebook></a>
<a href=https://www.reddit.com/r/godot target=_blank rel=noopener><img src=/assets/footer/reddit_logo.svg width=32 height=32 alt=Red​dit></a>
<a href=/rss.xml target=_blank rel=noopener><img src=/assets/footer/feed_logo.svg width=32 height=32 alt="RSS feed"></a></div></div></div></footer><script defer src=/assets/js/tobii.min.js></script>
<script defer src=/assets/js/highlight.min.js?1></script>
<script defer src=/assets/js/highlight.gdscript.min.js?1></script>
<script>document.addEventListener('DOMContentLoaded',()=>{document.querySelectorAll('pre code').forEach(a=>{hljs.highlightBlock(a)}),document.querySelectorAll('[data-post-date]').forEach(a=>{Date.parse(a.dataset.postDate)>Date.now()-1e3*60*60*48&&a.classList.add("post-recent-highlight")}),new Tobii({zoom:!1});const a=document.querySelectorAll('.set-os-download-url');for(let b=0;b<a.length;b++){const c=a[b];let e='download';'version'in c.dataset&&c.dataset.version==='3'&&(e='download/3.x');let d='windows';navigator.platform.indexOf('Mac')!==-1?d='macos':navigator.platform.indexOf('Linux')!==-1&&(d='linux'),c.href=`/${e}/${d}/`}})</script>