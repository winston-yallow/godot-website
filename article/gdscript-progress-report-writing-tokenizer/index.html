<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Godot Engine"><meta name=description content="GDScript is being rewritten. In this article we talk about the new tokenizer—the first step in the compilation process."><meta name=theme-color content="#3d8fcc"><meta property="og:site_name" content="Godot Engine"><meta property="og:url" content="https://godotengine.org/article/gdscript-progress-report-writing-tokenizer/"><meta name=twitter:site content="@godotengine"><meta property="og:title" content="GDScript progress report: Writing a tokenizer"><meta property="og:description" content="GDScript is being rewritten. In this article we talk about the new tokenizer—the first step in the compilation process."><meta property="og:image" content="https://godotengine.org/storage/app/uploads/public/5eb/018/a65/5eb018a659a8f843228718.png"><meta property="og:type" content="article"><meta name=twitter:card content="summary_large_image"><title>GDScript progress report: Writing a tokenizer</title><link rel=alternate type=application/rss+xml title="Godot News" href=/rss.xml><link rel=icon href=/assets/favicon.png sizes=any><link rel=icon href=/assets/favicon.svg type=image/svg+xml><link rel=stylesheet href=/assets/css/main.css?112><link rel=stylesheet href=/assets/css/tobii.min.css><link rel=preload as=font href=/assets/fonts/Montserrat-Bold.woff2 crossorigin><link rel=preload as=font href=/assets/fonts/Montserrat-ExtraBold.woff2 crossorigin><link rel=me href=https://mastodon.gamedev.place/@godotengine><input type=checkbox id=nav_toggle_cb><header><div class="container flex align-center"><div id=nav_head><a href=/ id=logo-link><img class=nav-logo src=/assets/logo.svg width=136 height=48 alt="Godot Engine">
<img class="nav-logo dark-logo" src=/assets/logo_dark.svg width=136 height=48 alt="Godot Engine"></a>
<label for=nav_toggle_cb id=nav_toggle_btn><img src=/assets/icons/hamburger.svg width=24 height=24 alt="Main menu"></label></div><nav id=nav><ul class=left><li><a href=/features/>Features</a><li class=only-on-mobile><a href=/showcase/>Showcase</a><li><a href=/blog/>Blog</a><li><a href=/community/>Community</a><li><a href=/contact/>About</a><li><a href=https://godotengine.org/asset-library/asset>Assets</a></ul><ul class=right><li><a href=/download/windows/ class=set-os-download-url>Download</a><li><a href=https://docs.godotengine.org>Docs</a><li><a href=https://docs.godotengine.org/en/stable/community/contributing/index.html>Contribute</a><li class=fund><a href=https://fund.godotengine.org>❤&#xFE0E; Donate</a></ul></nav></div></header><main><style>body{background-color:var(--background-color)}h1{margin-bottom:8px;margin-top:32px}:not(pre)>code{background:var(--code-background-color);padding:1px 4px;font-size:.95em;border-radius:3px}pre{background:var(--codeblock-background-color);color:var(--codeblock-color)}pre code{display:block;overflow-x:auto;padding:.5em}.date-big{line-height:2;margin-left:32px}article{background-color:var(--base-color);box-shadow:0 3px 2px rgba(0,0,0,.15)}figure{margin:0}figure img{margin:0}article img,article video{max-width:100%;height:auto;display:block;margin:auto;margin-top:16px;margin-bottom:16px}article h1{margin-top:64px}article h2,article h3,article h4{margin-top:42px}.article-info{display:flex;flex-direction:column;gap:8px}.article-metadata{display:flex;gap:24px;align-items:center;font-family:var(--header-font-family);margin-bottom:12px}@media(max-width:900px){.article-metadata{flex-direction:column;align-items:flex-start;gap:16px}}.article-author{color:var(--base-color-text-subtitle-date);font-weight:700;font-size:18px;flex-grow:1;display:flex;gap:12px;align-items:center}.article-author .avatar{border-radius:100%;margin:0}.article-author .by{color:var(--base-color-text-subtitle)}.article-metadata .date{color:var(--base-color-text-subtitle-date)}.article-metadata .date.post-recent-highlight{color:var(--post-recent-highlight-color);opacity:.8}.article-metadata .date.post-recent-highlight::after{font-size:80%;content:"NEW";border:2px solid var(--post-recent-highlight-color);padding:2px 3px;margin-left:8px}.tag.active{filter:saturate(.75)}@media screen and (min-width:900px){article .content{width:70%;margin:auto}}@media(max-width:900px){body{background-color:var(--base-color)}article{background-color:initial;box-shadow:none}article img:first-child,article video:first-child{max-width:100%}}</style><link rel=stylesheet href=/assets/css/highlight.obsidian.min.css><div class=container><article class=padded><div class="content article-container"><figure class=article-cover><img src=/storage/app/uploads/public/5eb/018/a65/5eb018a659a8f843228718.png title alt=" " class=rounded-lg style=width:100%;height:auto;background-color:initial></figure><div class=article-info><h1>GDScript progress report: Writing a tokenizer</h1><div class=article-metadata><div class=article-author><span>By:</span>
<img class=avatar width=25 height=25 src=/assets/images/authors/vnen.webp alt="George Marques" loading=lazy>
<span class=by>George Marques</span></div><span class=date data-post-date="2020-05-04 11:00:00 +0000">4 May 2020</span></div><div class=tags><a href=/blog/progress-report><div class="tag active">Progress Report</div></a></div></div><div class="card card-warning"><p>This article is from <strong>May 2020</strong>, some of its contents might be outdated and no longer accurate.<br>You can find up-to-date information about the engine in the <a href=https://docs.godotengine.org/en/stable/>official documentation</a>.</div><div class=article-body><p>Some of you may not be aware, but I’m currently rewriting GDScript. It was discussed during the last Godot Sprint in Brussels and the core developers approved the idea.<p>The main rationale to rewrite the GDScript implementation is that it has been changed so much that it’s gotten quite hard to understand after receiving so many new features. This is also an opportunity to clean up, tidy up, and modernize the code, like it happened for some other parts of the engine that got rewritten in the past years.<p>The objective is to have a more “textbook-like” compiler, which will help maintenance both by those already acquainted with the Godot source and by new faces who saw something about writing compilers in the past. Hopefully this will make it harder to mess something up, given this is critical code for the engine users.<p><em>See other articles in this Godot 4.0 GDScript series:</em><ol><li>(you are here) <a href=https://godotengine.org/article/gdscript-progress-report-writing-tokenizer>GDScript progress report: Writing a tokenizer</a><li><a href=https://godotengine.org/article/gdscript-progress-report-writing-new-parser>GDScript progress report: Writing a new parser</a><li><a href=https://godotengine.org/article/gdscript-progress-report-type-checking-back>GDScript progress report: Type checking is back</a><li><a href=https://godotengine.org/article/gdscript-progress-report-new-gdscript-now-merged>GDScript progress report: New GDScript is now merged</a><li><a href=https://godotengine.org/article/gdscript-progress-report-typed-instructions>GDScript progress report: Typed instructions</a><li><a href=https://godotengine.org/article/gdscript-progress-report-feature-complete-40>GDScript progress report: Feature-complete for 4.0</a></ol><h2 id=why-not-a-parser-generator>Why not a parser generator?</h2><p>I’ve seen this question more than once: why can’t we use a parser generator? Then we would just need to write a grammar specification and the generator makes the whole parser for us.<p>The main problem with parser generators—and the main reason modern language compilers don’t use them—is that it is incredibly hard to provide meaningful error messages to the users of the language. With hand-made parsers we can inject checks, such as properly validating the path you put in a <code class="language-plaintext highlighter-rouge">preload</code> statement, among other things.<p>The GDScript grammar is also pretty much settled (except maybe for a few of the new features) so we don’t benefit from prototyping and iterating on a grammar definition, which is the main selling point of parser generators.<h2 id=rewriting-the-tokenizer>Rewriting the tokenizer</h2><p>The first step when writing a compiler is to make the <em>tokenizer</em> (also called <em>scanner</em> by some authors). It has the responsibility of reading the characters of the source code and bundling them together as meaningful chunks which are called <em>tokens</em>. Tokens contain information about what they mean and where they occured. This makes the following compilation steps easier to manage as they don’t have to deal with minutiae such as comments and whitespace, which are not meaningful for the final execution.<p>I’m taking this opportunity to make the tokenizer a bit smarter (and maybe a bit dumber in some regards) in order to make the parsing simpler (I’ll write about the parser when I get there). The new tokenizer will emit special tokens when it detects there’s an indentation change and also a newline. Since GDScript is indentation based, this helps the parser identify the start and end of blocks. This approach is also used by Python, so I’m not being revolutionary here.<p>I’m also rewriting the <code class="language-plaintext highlighter-rouge">--test gd*</code> commands so they work with the new code. Those are very useful during this rewrite since they allow me test the steps of the compiler without needing to have everything ready. I can make sure the tokenizer is working properly before moving on to the parser.<h2 id=what-is-a-token>What is a token?</h2><p>A <strong>token</strong> is a data container which describes the characters in the source code as something meaningful for the programming language. The main thing to store is the token type (e.g. a symbol, an identifier, a keyword, etc.), which is a value taken from an enum, since there are limited variety. This is used by the parser to understand which statement to expect.<p>Another thing is the potential associated data. If it’s, say, a <code class="language-plaintext highlighter-rouge">+</code> sign it doesn’t matter since the type <code class="language-plaintext highlighter-rouge">Token::PLUS</code> is enough to recognize it, but a <code class="language-plaintext highlighter-rouge">Token::IDENTIFIER</code> needs to have the actual identifier to be referred. Literal values, such as numbers and strings, also need to be stored. The new tokenizer uses a single Variant to store this.<p>It’s also useful to store positional information about the token: line/column where it starts and ends. This is not useful for interpreting the code, but is incredibly valuable for creating readable error messages.<h2 id=features-of-the-new-tokenizer>Features of the new tokenizer</h2><p>As mentioned, the main reason for the rewrite is to make it smarter, so let me show off some of the new features.<h3 id=storing-correct-positional-data>Storing correct positional data</h3><p>The old tokenizer stored only line and column, but there are many tokens that span across many columns and some across multiple lines. For example, a snippet like this one:<div class="language-gdscript highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>var</span> <span class=n>x</span> <span class=o>=</span> <span class=s2>"string"</span>
<span class=n>x</span> <span class=o>+=</span> <span class=s2>"""</span><span class=se>\
</span><span class=s2>Multiline String
"""</span>
</code></pre></div></div><p>Can now be tokenized like this:<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>0001 var x = "string"
     ^^^
 --&gt; var
-------------------------------------------------------
0001 var x = "string"
         ^
 --&gt; Identifier(StringName) x
-------------------------------------------------------
0001 var x = "string"
           ^
 --&gt; =
-------------------------------------------------------
0001 var x = "string"
             ^^^^^^^^
 --&gt; Literal(String) string
-------------------------------------------------------
0001 var x = "string"
                     ^
 --&gt; Newline
-------------------------------------------------------
0002 x += """\
     ^
 --&gt; Identifier(StringName) x
-------------------------------------------------------
0002 x += """\
       ^^
 --&gt; +=
-------------------------------------------------------
0002 x += """\
0003 Multiline String
0004 """
     ^^^^^^^^^^^^^^^^
 --&gt; Literal(String) Multiline String

-------------------------------------------------------
0004 """
        ^
 --&gt; Newline
-------------------------------------------------------
EOF
</code></pre></div></div><p>This is actually the output of the new tokenizer test. It rewrites the lines and points to the whole span of the token. This is meant to improve error messages by pointing the user to the exact spot.<h3 id=creating-indentation-and-newline-tokens>Creating indentation and newline tokens</h3><p>While the previous tokenizer kept track of indentation characters and newlines, it let the parser decide the current indentation level, and whether or not a newline was relevant. The new one only generates a newline token when it’s not empty, and also emits tokens for indentation. For example:<div class="language-gdscript highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=s2>"start"</span>

	<span class=s2>"indent"</span>
		<span class=s2>"more indent"</span>
<span class=s2>"two dedents"</span>
</code></pre></div></div><p>Is tokenized like this:<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>0001 "start"
     ^^^^^^^
 --&gt; Literal(String) start
-------------------------------------------------------
0001 "start"
            ^
 --&gt; Newline
-------------------------------------------------------
0003     "indent"
     ^^^^
 --&gt; Indent
-------------------------------------------------------
0003     "indent"
         ^^^^^^^^
 --&gt; Literal(String) indent
-------------------------------------------------------
0003     "indent"
                 ^
 --&gt; Newline
-------------------------------------------------------
0004         "more indent"
     ^^^^^^^^
 --&gt; Indent
-------------------------------------------------------
0004         "more indent"
             ^^^^^^^^^^^^^
 --&gt; Literal(String) more indent
-------------------------------------------------------
0004         "more indent"
                          ^
 --&gt; Newline
-------------------------------------------------------
0005 "two dedents"
     ^
 --&gt; Dedent
-------------------------------------------------------
0005 "two dedents"
     ^
 --&gt; Dedent
-------------------------------------------------------
0005 "two dedents"
     ^^^^^^^^^^^^^
 --&gt; Literal(String) two dedents
-------------------------------------------------------
0005 "two dedents"
                  ^
 --&gt; Newline
-------------------------------------------------------
EOF
</code></pre></div></div><p>You can see that it detects a decrease in two levels by emitting two <code class="language-plaintext highlighter-rouge">dedent</code> tokens. It also doesn’t emit a newline on line 2 because it’s empty.<h3 id=error-reporting-and-leniency>Error reporting and leniency</h3><p>The old tokenizer only allowed for one error, after which it would only return the same error if you asked for a new token. Now it returns the error but keeps going through the process so you can detect many errors at once. So this:<div class="language-gdscript highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=s2>"invalid escape \h &lt;- here"</span>
		<span class=s2>"indent"</span>
	<span class=s2>"mismatched unindent"</span>
</code></pre></div></div><p>Gives this:<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>0001 "invalid escape \h &lt;- here"
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
 --&gt; Literal(String) invalid escape  &lt;- here
-------------------------------------------------------
0001 "invalid escape \h &lt;- here"
                     ^^
 --&gt; Error(String) Invalid escape in string.
-------------------------------------------------------
0001 "invalid escape \h &lt;- here"
                                ^
 --&gt; Newline
-------------------------------------------------------
0002         "indent"
     ^^^^^^^^
 --&gt; Indent
-------------------------------------------------------
0002         "indent"
             ^^^^^^^^
 --&gt; Literal(String) indent
-------------------------------------------------------
0002         "indent"
                     ^
 --&gt; Newline
-------------------------------------------------------
0003     "mismatched unindent"
     ^^^^^
 --&gt; Error(String) Unindent doesn't match the previous indentation level.
-------------------------------------------------------
0003     "mismatched unindent"
     ^^^^^
 --&gt; Dedent
-------------------------------------------------------
0003     "mismatched unindent"
         ^^^^^^^^^^^^^^^^^^^^^
 --&gt; Literal(String) mismatched unindent
-------------------------------------------------------
0003     "mismatched unindent"
                              ^
 --&gt; Newline
-------------------------------------------------------
0004
     ^
 --&gt; Dedent
-------------------------------------------------------
EOF
</code></pre></div></div><p>You can notice that the error in the string comes after the string token. That’s okay because the parser will report all errors at once and they will be sorted by position.<p>Indentation level is also correctly maintained even in case of a mismatch (that’s why there’s two dedents for one indent). This is helpful to keep the parsing lenient in some special cases, which I’ll talk more about when I write about the parser.<h3 id=recognizing-extra-tokens>Recognizing extra tokens</h3><p>Some characters and sequences aren’t allowed in the source code but they can be tokenized so a better error message can be provided. Example:<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>? ` &lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt;
</code></pre></div></div><p>Result:<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>0001 ? ` &lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt;
     ^
 --&gt; ?
-------------------------------------------------------
0001 ? ` &lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt;
       ^
 --&gt; `
-------------------------------------------------------
0001 ? ` &lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt;
         ^^^^^^^
 --&gt; VCS conflict marker
-------------------------------------------------------
0001 ? ` &lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt;
                 ^^^^^^^
 --&gt; VCS conflict marker
-------------------------------------------------------
0001 ? ` &lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt;
                         ^^^^^^^
 --&gt; VCS conflict marker
-------------------------------------------------------
0001 ? ` &lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt;
                                ^
 --&gt; Newline
-------------------------------------------------------
EOF
</code></pre></div></div><p>The question mark can be recognized as an attempt to use the C-style ternary conditional operator, so we can show the user the correct operator for GDScript.<p>We also recognize conflict markers so you can easily notice that you have a merge conflict in the file.<h2 id=what-comes-next>What comes next</h2><p>Now that the tokenizer is pretty much done, I’ll start rewriting the parser, which is responsible for reading the sequence of tokens and making sense out of them, deciding if it’s a function, variable, expression, etc. I’ll write more about it when I have something to show.</div></div></article></div><link rel=stylesheet href=/assets/css/anchor-link.css?1><link rel=stylesheet href=/assets/css/article-cards.css?2><script src=/assets/js/anchor-link.js></script>
<script>document.addEventListener('DOMContentLoaded',()=>{window.applyAnchorLinks('.article-body'),document.querySelectorAll('.article-cover img, .article-body img').forEach(b=>{if(b.classList.contains('lightbox-ignore'))return;const a=document.createElement('a');a.href=b.src,a.classList.add('lightbox'),a.dataset.group='article',b.parentNode.appendChild(a),a.appendChild(b)})})</script></main><footer><div class="container flex footer-container"><div id=copyright><p>© 2007-2024 Juan Linietsky, Ariel Manzur and <a href=https://github.com/godotengine/godot/blob/master/AUTHORS.md target=_blank rel=noopener>contributors</a>.<br>Hosted by the <a href=https://godot.foundation/ target=_blank rel=noopener>Godot Foundation</a>.<br>Website <a href=https://github.com/godotengine/godot-website target=_blank rel=noopener>source code on GitHub</a>.</div><div id=sitemap><ul class=sitemap-group><li><strong>Get Godot</strong><li><a href=/download/windows/ class=set-os-download-url>Download</a><li><a href=/download/archive/>Release Archive</a><li><a href=https://editor.godotengine.org/releases/latest/>Web Editor</a><li>&nbsp;<li><strong>Public Relations</strong><li><a href=/blog/>Blog</a><li><a href=/community/>Communities and Events</a><li><a href=/press/>Press Kit</a></ul><ul class=sitemap-group><li><strong>About Godot</strong><li><a href=/features/>Features</a><li><a href=/showcase/>Showcase</a><li><a href=/education/>Education</a><li><a href=/license/>License</a><li><a href=/code-of-conduct/>Code of Conduct</a><li><a href=/privacy-policy/>Privacy Policy</a><li><a href=https://fund.godotengine.org>Donate</a></ul><ul class=sitemap-group><li><strong>Project Team</strong><li><a href=/governance/>Governance</a><li><a href=/teams/>Teams</a><li>&nbsp;<li><strong>Extra Resources</strong><li><a href=https://godotengine.org/asset-library/asset>Asset Library</a><li><a href=https://docs.godotengine.org>Documentation</a><li><a href=https://github.com/godotengine>Code Repository</a></ul></div><div id=social class=dark-desaturate><h4 class=text-right><a href=/contact/>Contact us</a></h4><div class="flex justify-space-between" style=gap:3px><a href=https://github.com/godotengine target=_blank rel=noopener><img src=/assets/footer/github_logo.svg width=32 height=32 alt=GitHub></a>
<a href=https://mastodon.gamedev.place/@godotengine target=_blank rel=noopener><img src=/assets/footer/mastodon_logo.svg width=32 height=32 alt=Mastodon></a>
<a href=https://twitter.com/godotengine target=_blank rel=noopener><img src=/assets/footer/twitter_logo.svg width=32 height=32 alt=Twitter></a>
<a href=https://www.facebook.com/groups/godotengine/ target=_blank rel=noopener><img src=/assets/footer/facebook_logo.svg width=32 height=32 alt=Facebook></a>
<a href=https://www.reddit.com/r/godot target=_blank rel=noopener><img src=/assets/footer/reddit_logo.svg width=32 height=32 alt=Red​dit></a>
<a href=/rss.xml target=_blank rel=noopener><img src=/assets/footer/feed_logo.svg width=32 height=32 alt="RSS feed"></a></div></div></div></footer><script defer src=/assets/js/tobii.min.js></script>
<script defer src=/assets/js/highlight.min.js?1></script>
<script defer src=/assets/js/highlight.gdscript.min.js?1></script>
<script>document.addEventListener('DOMContentLoaded',()=>{document.querySelectorAll('pre code').forEach(a=>{hljs.highlightBlock(a)}),document.querySelectorAll('[data-post-date]').forEach(a=>{Date.parse(a.dataset.postDate)>Date.now()-1e3*60*60*48&&a.classList.add("post-recent-highlight")}),new Tobii({zoom:!1});const a=document.querySelectorAll('.set-os-download-url');for(let b=0;b<a.length;b++){const c=a[b];let e='download';'version'in c.dataset&&c.dataset.version==='3'&&(e='download/3.x');let d='windows';navigator.platform.indexOf('Mac')!==-1?d='macos':navigator.platform.indexOf('Linux')!==-1&&(d='linux'),c.href=`/${e}/${d}/`}})</script>