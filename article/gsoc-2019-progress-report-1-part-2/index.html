<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Godot Engine"><meta name=description content="Godot takes part in the Google Summer of Code for the second year, and this time we have 8 students working on awesome features for the engine. They each share their project aim and current progress with a short devlog. This common progress report is split over two blog posts for readability. This post covers work on rewriting the light mapper (Joan Fons Sanchez), a static analyzer for GDScript (Suhas Prasanna), motion matching (Aditya Abhiram) and asynchronous cached file access (Raghav Shankar)."><meta name=theme-color content="#3d8fcc"><meta property="og:site_name" content="Godot Engine"><meta property="og:url" content="https://godotengine.org/article/gsoc-2019-progress-report-1-part-2/"><meta name=twitter:site content="@godotengine"><meta property="og:title" content="GSoC 2019 progress report #1 (part 2)"><meta property="og:description" content="Godot takes part in the Google Summer of Code for the second year, and this time we have 8 students working on awesome features for the engine. They each share their project aim and current progress with a short devlog. This common progress report is split over two blog posts for readability. This post covers work on rewriting the light mapper (Joan Fons Sanchez), a static analyzer for GDScript (Suhas Prasanna), motion matching (Aditya Abhiram) and asynchronous cached file access (Raghav Shankar)."><meta property="og:image" content="https://godotengine.org/storage/app/uploads/public/5d3/04f/f48/5d304ff480b0c840286811.png"><meta property="og:type" content="article"><meta name=twitter:card content="summary_large_image"><title>GSoC 2019 progress report #1 (part 2)</title><link rel=alternate type=application/rss+xml title="Godot News" href=/rss.xml><link rel=icon href=/assets/favicon.png sizes=any><link rel=icon href=/assets/favicon.svg type=image/svg+xml><link rel=stylesheet href=/assets/css/main.css?112><link rel=stylesheet href=/assets/css/tobii.min.css><link rel=preload as=font href=/assets/fonts/Montserrat-Bold.woff2 crossorigin><link rel=preload as=font href=/assets/fonts/Montserrat-ExtraBold.woff2 crossorigin><link rel=me href=https://mastodon.gamedev.place/@godotengine><input type=checkbox id=nav_toggle_cb><header><div class="container flex align-center"><div id=nav_head><a href=/ id=logo-link><img class=nav-logo src=/assets/logo.svg width=136 height=48 alt="Godot Engine">
<img class="nav-logo dark-logo" src=/assets/logo_dark.svg width=136 height=48 alt="Godot Engine"></a>
<label for=nav_toggle_cb id=nav_toggle_btn><img src=/assets/icons/hamburger.svg width=24 height=24 alt="Main menu"></label></div><nav id=nav><ul class=left><li><a href=/features/>Features</a><li class=only-on-mobile><a href=/showcase/>Showcase</a><li><a href=/blog/>Blog</a><li><a href=/community/>Community</a><li><a href=/contact/>About</a><li><a href=https://godotengine.org/asset-library/asset>Assets</a></ul><ul class=right><li><a href=/download/windows/ class=set-os-download-url>Download</a><li><a href=https://docs.godotengine.org>Docs</a><li><a href=https://docs.godotengine.org/en/stable/community/contributing/index.html>Contribute</a><li class=fund><a href=https://fund.godotengine.org>❤&#xFE0E; Donate</a></ul></nav></div></header><main><style>body{background-color:var(--background-color)}h1{margin-bottom:8px;margin-top:32px}:not(pre)>code{background:var(--code-background-color);padding:1px 4px;font-size:.95em;border-radius:3px}pre{background:var(--codeblock-background-color);color:var(--codeblock-color)}pre code{display:block;overflow-x:auto;padding:.5em}.date-big{line-height:2;margin-left:32px}article{background-color:var(--base-color);box-shadow:0 3px 2px rgba(0,0,0,.15)}figure{margin:0}figure img{margin:0}article img,article video{max-width:100%;height:auto;display:block;margin:auto;margin-top:16px;margin-bottom:16px}article h1{margin-top:64px}article h2,article h3,article h4{margin-top:42px}.article-info{display:flex;flex-direction:column;gap:8px}.article-metadata{display:flex;gap:24px;align-items:center;font-family:var(--header-font-family);margin-bottom:12px}@media(max-width:900px){.article-metadata{flex-direction:column;align-items:flex-start;gap:16px}}.article-author{color:var(--base-color-text-subtitle-date);font-weight:700;font-size:18px;flex-grow:1;display:flex;gap:12px;align-items:center}.article-author .avatar{border-radius:100%;margin:0}.article-author .by{color:var(--base-color-text-subtitle)}.article-metadata .date{color:var(--base-color-text-subtitle-date)}.article-metadata .date.post-recent-highlight{color:var(--post-recent-highlight-color);opacity:.8}.article-metadata .date.post-recent-highlight::after{font-size:80%;content:"NEW";border:2px solid var(--post-recent-highlight-color);padding:2px 3px;margin-left:8px}.tag.active{filter:saturate(.75)}@media screen and (min-width:900px){article .content{width:70%;margin:auto}}@media(max-width:900px){body{background-color:var(--base-color)}article{background-color:initial;box-shadow:none}article img:first-child,article video:first-child{max-width:100%}}</style><link rel=stylesheet href=/assets/css/highlight.obsidian.min.css><div class=container><article class=padded><div class="content article-container"><figure class=article-cover><img src=/storage/app/uploads/public/5d3/04f/f48/5d304ff480b0c840286811.png title alt=" " class=rounded-lg style=width:100%;height:auto;background-color:initial></figure><div class=article-info><h1>GSoC 2019 progress report #1 (part 2)</h1><div class=article-metadata><div class=article-author><span>By:</span>
<img class=avatar width=25 height=25 src=/assets/images/authors/akien.webp alt="Rémi Verschelde" loading=lazy>
<span class=by>Rémi Verschelde</span></div><span class=date data-post-date="2019-07-18 10:56:18 +0000">18 July 2019</span></div><div class=tags><a href=/blog/progress-report><div class="tag active">Progress Report</div></a></div></div><div class="card card-warning"><p>This article is from <strong>July 2019</strong>, some of its contents might be outdated and no longer accurate.<br>You can find up-to-date information about the engine in the <a href=https://docs.godotengine.org/en/stable/>official documentation</a>.</div><div class=article-body><p>As mentioned in the <a href=/article/gsoc-2019-progress-report-1-part-1>first part of this progress report</a>, Godot is taking part in the Google Summer of Code (GSoC) programme for the second time, and we have 8 students working on specific projects for Godot Engine.<p>We’re now in the middle of the GSoC 3-months coding period, and we asked students to write a progress report to present their project and the work done so far. The 8 reports are split over two posts, the first 4 of which <a href=/article/gsoc-2019-progress-report-1-part-1>was posted yesterday</a>. This second post will cover the remaining 4 projects.<p>Here is the list of projects and students with links to the relevant sections.<p><strong>Part 1 (<a href=/article/gsoc-2019-progress-report-1-part-1>previous post</a>):</strong><ul><li><a href=/article/gsoc-2019-progress-report-1-part-1#vcs-integration>Version Control Systems Integration</a> by Twarit Waikar<li><a href=/article/gsoc-2019-progress-report-1-part-1#interactive-music>Interactive Music</a> by Daniel Matarov<li><a href=/article/gsoc-2019-progress-report-1-part-1#gdscript-lsp>GDScript Language Server</a> by Ankit Priyarup<li><a href=/article/gsoc-2019-progress-report-1-part-1#visual-scripting>Improvements to the Visual Scripting System</a> by Swarnim Arun</ul><p><strong>Part 2 (this post):</strong><ul><li><a href=#lightmapper>Rewriting Godot’s Light Mapper</a> by Joan Fons Sanchez<li><a href=#static-analyzer>Static Analyzer for GDScript</a> by Suhas Prasanna<li><a href=#motion-matching>Motion Matching Implementation Using KD Trees</a> by Aditya Abhiram<li><a href=#async-file-access>Asynchronous Cached File Access</a> by Raghav Shankar</ul><hr><p><a id=lightmapper></a><h2 id=rewriting-godots-light-mapper--joan-fons-sanchez>Rewriting Godot’s Light Mapper – <em>Joan Fons Sanchez</em></h2><ul><li><strong>Project:</strong> Rewriting Godot’s Light Mapper<li><strong>Student:</strong> Joan Fons Sanchez (<a href=https://github.com/JFonS>JFonS</a>)<li><strong>Mentors:</strong> Juan Linietsky (<a href=https://github.com/reduz>reduz</a>) and Bastiaan Olij (<a href=https://github.com/BastiaanOlij>BastiaanOlij</a>)<li><strong>Repository:</strong> https://github.com/JFonS/godot/tree/lightmapper</ul><h3 id=project-description>Project description</h3><p>Light maps are a really easy way to improve performance on statically lit scenes. Instead of computing the amount of light that reaches a certain surface every frame for every light source, we precompute all this information and store it in a single texture. This means having lots of lights no longer creates a performance hit on the rendering pipeline, since all we need to do is sample a single texture and we get the amount of light coming from all light sources.<p>Godot’s 3.1 light mapper is based on the same approach used in <a href=https://docs.godotengine.org/en/3.1/tutorials/3d/gi_probes.html>global illumination</a>. That means the whole scene is subdivided in a regular grid of voxels and, for each of these voxels, we compute the amount of light reaching it. This allows us to have some great results for computing real time illumination, but the discretization of the scene has various downsides (e.g. some walls may be thinner than the size of a voxel, therefore they can leak light through them).<p>The main goal of my GSoC project is to completely rewrite the light mapper in Godot and, instead of a voxel approach, use ray tracing to compute the scene lighting. This will hopefully give better looking light maps and will reduce the amount of artifacts such as self occlusions or light leaks.<h3 id=current-progress>Current progress</h3><p>During the first weeks of coding I added caching to UV2 generation. The process of generating light map texture coordinates takes a while, and it was being triggered on every scene reimport. By adding a simple cache to it, we made it so that light map texture coordinates are only computed when there’s an actual change to the geometry of the mesh.<p>With that simple task out of the way my main focus went to getting the direct illumination pass done. That involved generating the actual light map texture and, for every light inside the <code class="language-plaintext highlighter-rouge">BakedLightmap</code> node, compute the amount of light reaching every texel.<p>Here you can see the Sponza demo model, with baked direct lighting, and the corresponding light map:<p><img src=/storage/app/media/gsoc/2019-1/lightmap-001.png alt="Sponza scene with baked direct lighting"><p><img src=/storage/app/media/gsoc/2019-1/lightmap-002.png alt="Light map texture for above scene"><p>Note that this first pass is not taking occlusion into account yet. That will be added in the following weeks.<h3 id=next-steps>Next steps</h3><p>I’m currently working on integrating <a href=https://www.embree.org>Embree</a> as a ray tracing library into the Godot editor. Once I get it fully working I will use it to add occlusion tests to the direct light pass as well as doing all the required computations for indirect lighting.<p>The first results will probably look noisy and with graphical artifcats, so I will spend some time implementing all the tips and tricks detailed in this <a href=https://ndotl.wordpress.com/2018/08/29/baking-artifact-free-lightmaps/>wonderful article</a>. If I still have some time left I will take a look at adding some sort of AI denoiser, but I can’t promise anything :)<hr><p><a id=static-analyzer></a><h2 id=static-analyzer-for-gdscript--suhas-prasanna>Static Analyzer for GDScript – <em>Suhas Prasanna</em></h2><ul><li><strong>Project:</strong> Static Analyzer for GDScript<li><strong>Student:</strong> Suhas Prasanna (<a href=https://github.com/psuhas77>psuhas77</a>)<li><strong>Mentors:</strong> George Marques (<a href=https://github.com/vnen>vnen</a>) and Bojidar Marinov (<a href=https://github.com/bojidar-bg>bojidar-bg</a>)<li><strong>Repository:</strong> https://github.com/psuhas77/godot/tree/gsoc</ul><h3 id=introduction>Introduction</h3><p>While making medium to large scale games in Godot, many small bugs start to creep in that cannot be caught by the compiler. These can only be dealt with manually while debugging. This project will build a tool to be used semi-regularly to highlight these problematic pieces of code in an automated fashion. This essentially extends the scope of static checks, currently just done within each script, to operate across scripts and scenes.<p>It can be used to deal with things such as non-existent node being referenced in a <code class="language-plaintext highlighter-rouge">get_node()</code> call, wrong arguments in a function connected to a signal, etc.<h3 id=what-kind-of-static-checks-can-be-expected>What kind of static checks can be expected?</h3><p>Within the time frame of this GSoC, these are the static checks that can be expected to be completed:<ul><li>Check to ensure a script does not refer to a non-existent node in the scene (this can be a problem when nodes are deleted or the tree is re-organized).<li>Check to ensure that a script does not refer to a non-existent method/property in the node (this can be a problem when there is a change type operation).<li>Check to ensure that the arity and type of arguments declared in a function connected to a signal are correct.</ul><p>However, this is not an exhaustive list and hopefully many more can be completed by the time GSoC ends.<h3 id=current-state>Current state</h3><h4 id=ui>UI</h4><p>The UI so far is still a work in progress (since most of the work done so far is behind the scenes), however you can expect the final tool to reside here:<p><img src=/storage/app/media/gsoc/2019-1/static-analyzer-001.jpg alt="Static Analyzer menu entry in the editor"><h4 id=behind-the-scenes>Behind the scenes</h4><p>The way I’m going about this is to essentially go through each scene and within that, traverse through each script to check if there is any potentially problematic code. Then that particular code can be checked to ensure that it is correct (e.g. ensure that the <code class="language-plaintext highlighter-rouge">NodePath</code> in a <code class="language-plaintext highlighter-rouge">get_node</code> call does point to an actual node). Further optimizations will be done so it isn’t necessary to process the same scripts again and again.<p>Currently, the mechanism to traverse from scene to scene, as well as ensure that the scene files are valid, is complete. Most of the mechanism to traverse through any particular script is done as well. So, it can run through each scene file, make sure it’s valid, and extract scripts from the nodes within the scenes to perform static checks on them.<h3 id=what-next>What next</h3><p>The Scene Traversal mechanism needs to be fully finished. Once that is done, I can start working on the static checks. The few mentioned in this post will be created first and based on the time remaining, more can be implemented. The last step will be to tidy up the UI and ensure that the tool works with extensive testing. Looking forward to a fruitful next couple of months.<hr><p><a id=motion-matching></a><h2 id=motion-matching-implementation-using-kd-trees--aditya-abhiram>Motion Matching Implementation Using KD Trees – <em>Aditya Abhiram</em></h2><ul><li><strong>Project:</strong> Motion Matching Implementation Using KD Trees<li><strong>Student:</strong> Aditya Abhiram (<a href=https://github.com/Aa20475>Aa20475</a>)<li><strong>Mentors:</strong> Juan Linietsky (<a href=https://github.com/reduz>reduz</a>) and <a href=https://github.com/karroffel>karroffel</a><li><strong>Repository:</strong> https://github.com/Aa20475/godot/tree/godot-motion-matching</ul><h3 id=introduction-1>Introduction</h3><p>Hey! This is Aditya Abhiram a.k.a. DestinyGamer. I am working on the implementation of <em>Motion Matching</em> in Godot.<p>First of all, I want to thank the Godot project and my mentors, Juan Linietsky and karroffel, for giving me a chance to work on this project.<p>Godot, being an open source game engine, was built with a <em>never-ending wish of adding new features to it</em>.<p>Motion matching is one of the latest features in game animation which is quite revolutionary. Usually, setting up a basic animation system needs a lot of work and time. Even after that, we barely manage to make a perfect one. Motion matching, on the other hand is a method where the computer chooses the best pose for each frame by itself from a huge database of motion capture (<em>MoCap</em>) data using some algorithm.<blockquote><p>Choose the best pose for each frame and jump to it!</blockquote><p>This wonderful feature needs to be included in Godot!<h3 id=overview>Overview</h3><p>This project has three parts:<ul><li>Cost function<li>Future trajectory prediction model<li>KDTrees for KNN search (optimisation)</ul><p>We started off by collecting datasets for testing while reduz worked on the UI of the editor. Along with data collection, I tried out implementing KDTree and KNN search. The UI was ready by mid June and then I started adding and testing the KDTree and KNN search algorithms with it.<h4 id=animationnodemotionmatch-in-animationtree><code class="language-plaintext highlighter-rouge">AnimationNodeMotionMatch</code> in <code class="language-plaintext highlighter-rouge">AnimationTree</code>:</h4><p><img src=/storage/app/media/gsoc/2019-1/motion-matching-001.gif alt="AnimationNodeMotionMatch in AnimationTree"><h4 id=animationnodemotionmatcheditor-ui><code class="language-plaintext highlighter-rouge">AnimationNodeMotionMatchEditor</code> UI:</h4><p><img src=/storage/app/media/gsoc/2019-1/motion-matching-002.png alt=AnimationNodeMotionMatchEditor><p>Just before the first evaluation [<em>ed.</em> after one month of coding], I successfully added KDTree and KNN search to the <code class="language-plaintext highlighter-rouge">AnimationNodeMotionMatch</code>.<p>During the evaluation period, I tried making a simple future trajectory prediction models.<p>After that, I started implementing <em>Pose and Trajectory Matching</em> (i.e. calculating the cost function using pose and root trajectory comparisons) without including KDTrees yet (just as a brute force attempt). I’m still working on fixing the crashes in this matching.<h4 id=animation-player-not-set-error>‘Animation Player not set’ error:</h4><p><img src=/storage/app/media/gsoc/2019-1/motion-matching-003.gif alt="'Animation Player not set' error"><h4 id=root-motion-track-not-set-error>‘Root Motion Track not set’ error:</h4><p><img src=/storage/app/media/gsoc/2019-1/motion-matching-004.gif alt="'Root Motion Track not set' error"><h3 id=things-to-do>Things to do</h3><ul><li>Getting Pose and Trajectory Matching running without any crashes.<li>Adding Velocity Matching too so that the matching gets more natural.<li>Taking past data into account during matching, so that we won’t ignore weight-shifts and get a natural looking animation.<li>Replacing the brute force approach with KNN search using KDTrees.<li>Adding sliders for parameters such as Pose and Trajectory, etc.<li>Many more additions needed to the UI.</ul><hr><p><a id=async-file-access></a><h2 id=asynchronous-cached-file-access--raghav-shankar>Asynchronous Cached File Access – <em>Raghav Shankar</em></h2><ul><li><strong>Project:</strong> Asynchronous Cached File Access<li><strong>Student:</strong> Raghav Shankar (<a href=https://gist.github.com/WarpspeedSCP>WarpspeedSCP</a>)<li><strong>Mentors:</strong> Ariel Manzur (<a href=https://github.com/punto->punto-</a>) and HP van Braam (<a href=https://github.com/hpvb>hpvb</a>)<li><strong>Repository:</strong> https://github.com/WarpspeedSCP/godot/tree/wip-patch</ul><h3 id=about-this-project>About this project</h3><p>Godot Engine is pretty easy to use for most things and is becoming a better competitor to Unreal Engine and Unity by the day. But one area where it’s lagging behind is in the way it handles file and network IO on various platforms, especially on systems like consoles.<p>Nowadays, all IO operations are cached to speed up access to data from hard drives or the network. The cache sits in RAM and holds on to information that is frequently accessed so we don’t need to wait a long time for the data. For desktop and mobile systems (like android and iOS), this may be less of a problem because the OS can provide caching for disk and network IO. But consoles and other more specialised systems may not have an OS that does this for us, which means we may need to do the caching ourselves.<p>The current mechanism that Godot Engine provides for such cases is pretty bad – it only reads ahead, it doesn’t allow for seeking backwards and it’s only for files on disk. My project aims to provide a more flexible solution that manages caching centrally, and allows for using different caching strategies as the situation demands through a C++ module which can be dropped in at compile time.<h3 id=current-progress-1>Current progress</h3><p>As of now, about half of the project’s goals are complete. I have created a cache structure that can hold data from multiple files which may be cached under different policies like FIFO (first in, first out) or LRU (least recently used).<p>The system is designed so that the actual interaction with the network/file system, which may take time, takes place on a separate thread alongside the rest of the engine. If data is already in the cache because we’ve read ahead a little, access will be much faster. Otherwise, we only need to wait a little while the bits of the file that are needed are loaded in the background.<p>The engine sees a normal file interface which it can use to read, write and seek within a file. Behind this frontend, the module keeps track of what parts of the file are in the cache, and loads more of the file into the cache on demand.<p>The cache breaks each file into a bunch of equally sized parts which can be easily shifted in and out of the cache.<p>There are three different caching algorithms I’ve set up.<h4 id=fifo-first-in-first-out>FIFO (First In First Out)</h4><p>FIFO is a straigntforward algorithm that just reads ahead by some number of parts. If the cache runs out of space, this algorithm discards the oldest part first. This may be ok for a file that doesn’t ever need to be seeked through, and which will only be read sequentially.<h4 id=lru-least-recently-used>LRU (Least Recently Used)</h4><p>LRU is a great caching algorithm that handles cases where we may read old data again very well. My particular implementation keeps a list of parts in order of the time they were accessed. When we run out of space, we discard the part that was accessed least recently (hence the name).<h4 id=permanent-store>Permanent store</h4><p>Sometimes we may want to use a file for a really long time, to the point where it’s probably going to be open the entire time the game is running. Maybe it’s for logging, or for autosaving progress. I’ve included a caching policy for this use case as well. Parts of files that are accessed with this policy are cached in the same manner as with LRU, except that permanent cached parts cannot be replaced by parts of other files.<p>For example, if we have a choice betweeen a permanent part and an LRU part which may be replaced, we must choose to replace the LRU part instead of the permanent one.<h4 id=summary>Summary</h4><p>Currently, files can be read from and I’ve got some GDScript integration set up to test things. I want to be able to write to files as well, but right now there are still a few bugs in the read logic that I need to squash.<h3 id=whats-next>What’s next?</h3><p>For now, the module uses standard library file handling functions in the backend. These can be switched out for the platform specific unbuffered IO functions. That way, things won’t be cached twice by both the OS and the engine. I plan to add unbuffered versions of the <code class="language-plaintext highlighter-rouge">FileAccess</code> class specific to each platform for this reason.<p>By August, this module should be feature complete with regards to my proposal.<h3 id=what-more-can-be-done>What more can be done?</h3><p>I want to provide support for something like magic streams, which are a way to store assets as a contiguous stream of data, where assets are stored in the order they are accessed in a game. So for a game, if the splash screen asset is loaded first, and then a character model, the magic stream for the game would have the contents of the splash image file appearing first, then the contents of the model, and so on.<p>Magic streams are great because they reduce the amount of time spent seeking for hard drives (since all the assets are stored contiguously in one file), and could also be useful for streaming assets over the network (just one request for all the data).<p>I also think this module could serve as a basis for streamlining the asset loading pipeline for Godot engine, which is currently single threaded.<hr><p>That’s it for this second batch of progress reports from our GSoC students. The first four reports will be can be read in the <a href=/article/gsoc-2019-progress-report-1-part-1>previous blog post</a>, and we should have a second progress report from all students towards the end of the coding period.<p>We hope that you will find good use cases for all the features that are being worked on, and we thank all students and mentors for their dedicated work on these projects!</div></div></article></div><link rel=stylesheet href=/assets/css/anchor-link.css?1><link rel=stylesheet href=/assets/css/article-cards.css?2><script src=/assets/js/anchor-link.js></script>
<script>document.addEventListener('DOMContentLoaded',()=>{window.applyAnchorLinks('.article-body'),document.querySelectorAll('.article-cover img, .article-body img').forEach(b=>{if(b.classList.contains('lightbox-ignore'))return;const a=document.createElement('a');a.href=b.src,a.classList.add('lightbox'),a.dataset.group='article',b.parentNode.appendChild(a),a.appendChild(b)})})</script></main><footer><div class="container flex footer-container"><div id=copyright><p>© 2007-2024 Juan Linietsky, Ariel Manzur and <a href=https://github.com/godotengine/godot/blob/master/AUTHORS.md target=_blank rel=noopener>contributors</a>.<br>Hosted by the <a href=https://godot.foundation/ target=_blank rel=noopener>Godot Foundation</a>.<br>Website <a href=https://github.com/godotengine/godot-website target=_blank rel=noopener>source code on GitHub</a>.</div><div id=sitemap><ul class=sitemap-group><li><strong>Get Godot</strong><li><a href=/download/windows/ class=set-os-download-url>Download</a><li><a href=/download/archive/>Release Archive</a><li><a href=https://editor.godotengine.org/releases/latest/>Web Editor</a><li>&nbsp;<li><strong>Public Relations</strong><li><a href=/blog/>Blog</a><li><a href=/community/>Communities and Events</a><li><a href=/press/>Press Kit</a></ul><ul class=sitemap-group><li><strong>About Godot</strong><li><a href=/features/>Features</a><li><a href=/showcase/>Showcase</a><li><a href=/education/>Education</a><li><a href=/license/>License</a><li><a href=/code-of-conduct/>Code of Conduct</a><li><a href=/privacy-policy/>Privacy Policy</a><li><a href=https://fund.godotengine.org>Donate</a></ul><ul class=sitemap-group><li><strong>Project Team</strong><li><a href=/governance/>Governance</a><li><a href=/teams/>Teams</a><li>&nbsp;<li><strong>Extra Resources</strong><li><a href=https://godotengine.org/asset-library/asset>Asset Library</a><li><a href=https://docs.godotengine.org>Documentation</a><li><a href=https://github.com/godotengine>Code Repository</a></ul></div><div id=social class=dark-desaturate><h4 class=text-right><a href=/contact/>Contact us</a></h4><div class="flex justify-space-between" style=gap:3px><a href=https://github.com/godotengine target=_blank rel=noopener><img src=/assets/footer/github_logo.svg width=32 height=32 alt=GitHub></a>
<a href=https://mastodon.gamedev.place/@godotengine target=_blank rel=noopener><img src=/assets/footer/mastodon_logo.svg width=32 height=32 alt=Mastodon></a>
<a href=https://twitter.com/godotengine target=_blank rel=noopener><img src=/assets/footer/twitter_logo.svg width=32 height=32 alt=Twitter></a>
<a href=https://www.facebook.com/groups/godotengine/ target=_blank rel=noopener><img src=/assets/footer/facebook_logo.svg width=32 height=32 alt=Facebook></a>
<a href=https://www.reddit.com/r/godot target=_blank rel=noopener><img src=/assets/footer/reddit_logo.svg width=32 height=32 alt=Red​dit></a>
<a href=/rss.xml target=_blank rel=noopener><img src=/assets/footer/feed_logo.svg width=32 height=32 alt="RSS feed"></a></div></div></div></footer><script defer src=/assets/js/tobii.min.js></script>
<script defer src=/assets/js/highlight.min.js?1></script>
<script defer src=/assets/js/highlight.gdscript.min.js?1></script>
<script>document.addEventListener('DOMContentLoaded',()=>{document.querySelectorAll('pre code').forEach(a=>{hljs.highlightBlock(a)}),document.querySelectorAll('[data-post-date]').forEach(a=>{Date.parse(a.dataset.postDate)>Date.now()-1e3*60*60*48&&a.classList.add("post-recent-highlight")}),new Tobii({zoom:!1});const a=document.querySelectorAll('.set-os-download-url');for(let b=0;b<a.length;b++){const c=a[b];let e='download';'version'in c.dataset&&c.dataset.version==='3'&&(e='download/3.x');let d='windows';navigator.platform.indexOf('Mac')!==-1?d='macos':navigator.platform.indexOf('Linux')!==-1&&(d='linux'),c.href=`/${e}/${d}/`}})</script>